<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>八月学习内容分享</title>
	<link rel="stylesheet" type="text/css" href="../dist/css/bootstrap.min.css">
	<link rel="stylesheet" type="text/css" href="../dist/css/myless.min.css">
	<link rel="stylesheet" type="text/css" href="../css/doc.css">
</head>
<body>
	<div class="container-fulid">
		<div class="header" data-spy="affix" data-offset-top="100" data-offset-bottom="200">
			<ul class="nav nav-success nav-pills nav-justified " >
			    <li role="presentation" class="active"><a href="#">less模块化开发</a></li>
			    <li role="presentation"><a href="#">grunt配置以及常用插件的使用</a></li>
			    <li role="presentation"><a href="#">javascript面向对象编程</a></li>
			    <li role="presentation"><a href="#">javascript函数</a></li>
	    	</ul>
		</div>
		<div class="container">
			<div class="row">
				<!-- 左侧内容区域 -->
				<div class="col-xs-9">
					<div class="content" id="less1">
						<h3>less模块化开发</h3>
						<div class="wrap">
							<p>安装node,安装全局 grunt 配置链接 <a href="">http://www.gruntjs.net/getting-started</a></p>
						</div>
						<div class="wrap" id="less2">
							<h4>配置package.json文件</h4>
							<p>打开node.js,进入项目的根目录，两种方法建package.json文件</p>
							<p>方法一：npm init命令</p>
							<p>方法二：直接手动在跟目录下创建package.json文件,然后在node 命令框中键入 npm install 命令则会加载 devDependencies 中配置的文件</p>
						</div>
						<div class="wrap" id="less3">
							<h4>配置Gruntfile.js文件 </h4>
							<p>参考地址<a href="http://www.gruntjs.net/configuring-tasks">配置Gruntfile.js</a></p>
						</div>
						<div class="wrap">
							<h4>Less文件规范</h4>
							<p>mixins存放函数文件</p>
							<p>根目录存放模块化的结构文件</p>
							<p>变量单独放一个文件中，便于以后更改查找 variables.less文件中</p>
						</div>
					</div>
					<div class="content" id="obj1">
						<div class="wrap1">
							<h3>面向对象</h3>
							<div class="wrap">
								<h4>对象声明</h4>
								<pre> var people= new Object();</pre>
								<pre> var people={a:1,b:2;};</pre>
							</div>
						</div>
						<div class="wrap1">
							<h4>ECMA-262中定义对象的属性类型：数据属性，访问器属性</h4>
							<div class="wrap">
								<h4>数据属性</h4>
								<p>数据属性：该属性包含了一个数据值的位置，它包含了4个描述行为的特性：</p>
								<p>1. [[Configurable]]：表示是否能通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。</p>
								<p>2. [[Enumerable]]：表示能否用for-in循环返回。</p>
								<p>3. [[writable]]：表示能否修改属性的值。</p>
								<p>4. [[Value]]：包含这个属性的数据值。读取属性值的时候从这个位置读，写入属性值的时候更新到这个位置，默认值为undefined。</p>

								<p>直接在对象上定义的属性的数据特性默认如下：</p>
								<p>1. [[Configurable]]：true</p>
								<p>2. [[Enumerable]]：true</p>
								<p>3. [[writable]]：true</p>
								<p>4. [[Value]]：”xiaochang” (初始时的赋值)</p>

								<p>这些特性不能直接被访问，要修改属性的特性只能通过Object.defineProperty( )方法，该方法包含三个参数：属性所在的对象，属性的名字，描述符对象</p>
								<p>调用Object.defineProperty( )方法时，如果不显示指定configurable，enumerable，writable的值，就默认为false</p>
							</div>
							<div class="wrap">
								<h4>访问器属性</h4>
								<p>包含getter和setter函数。读取访问器属性时，调用getter函数，返回有效的值；在写入访问器属性时，调用setter函数传入新值。它包含了4个特性：</p>
								<p>1. [[Configurable]]：表示是否能通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。</p>
								<p>2. [[Enumerable]]：表示能否用for-in循环返回。</p>
								<p>3. [[Get]]：读取属性时调用的函数，默认undefined。</p>
								<p>4. [[Set]]：写入属性时调用的函数，默认undefined。</p>
								<p>Object.defineProperties('对象',{要更改的属性值} )</p>
							</div>
						</div>
						<div class="wrap1" id="obj3">
							<h3>创建对象</h3>
							<div class="wrap">
								<h4>工厂模式</h4>
								<p>在函数内部创建一个私有对象，给对象添加属性和方法，然后返回这个对象 ，<a  target="_blank"  href="../Ch06/FactoryPatternExample01.htm">链接</a></p>
								<p>问题 ：未解决对象识别的问题</p>
							</div>
							<div class="wrap">
								<h4>构造函数模式</h4>
								<p>在构造函数中定义属性和方法，运行时自动出现在执行环境中 this <a target="_blank" href="../Ch06/ConstructorPatternExample01.htm">链接</a></p>
								<p>问题：构造函数中的方法在每个实例中重新构造一遍，实例对象中的函数不是同一函数</p>
								<p>将构造函数中的方法移到构造函数外面，引起新的问题，全局作用域中定义的对象只能被某个对象调用，并且很多构造函数有很多方法</p>
							</div>
							<div class="wrap">
								<h4>原型模式</h4>
								<p>创建的每个函数都有一个prototype的属性，这个属性是一个指针，指向一个对象</p>
								<p>在prototype上添加对象的属性和方法。</p>
								<p>原型链 (实例查找 ->  构造函数查找  -> 原型上查找)</p>
								<p>构造函数时一个空函数，所有实例共享属性和方法。<a href="../Ch06/ObjectPropertyNamesExample01.htm" target="_blank">链接</a></p>
								<p>在实例上更改属性方法。<a href="../Ch06/PrototypePatternExample02.htm" target="_blank">链接</a></p></p>
								<p>重写原型，问题，虽然 instanceof可以返回正确的结果，但是通过constructor无法确定类型 <a href="../Ch06/PrototypePatternExample07.htm" target="_blank">链接</a></p>
								<p>在原型上重写constructor属性，使之指向对象。导致constructor的 [[Enumerable]]特性可枚举，默认不可枚举<a href="../Ch06/PrototypePatternExample08.htm" target="_blank">链接</a></p>
								<p>重写原型链，切断了构造函数与最初的原型链之间的链接，重写构造函数之前声明的函数只能访问重写之前的原型链上的函数，不可访问重写原型链之后上面的函数。<a href="../Ch06/PrototypePatternExample09.htm" target="_blank">链接</a></p>
								<p>原型中的属性被所有实例共享，引用中表现的最为突出。<a href="../Ch06/PrototypePatternExample12.htm" target="_blank">链接</a></p>
							</div>
							<div class="wrap">
								<h4>组合使用构造函数</h4>
								<p>构造函数中写属性，原型上写方法。<a target="_blank" href="../Ch06/HybridPatternExample01.htm">链接</a></p>
								<p>问题：构造函数和原型独立</p>
							</div>
							<div class="wrap">
								<h4>动态原型模式</h4>
								<p>将原型写在构造函数内，通过调用时判断构造函数是否有每个方法，没有出事话原型方法。<a target="_blank" href="../Ch06/DynamicPrototypeExample01.htm">链接</a></p>
							</div>
						</div>
						<div class="wrap1" id="obj4">
							<h3>继承</h3>
							<div class="wrap">
								<h4>原型链</h4>
								<p>将父类的实例付给子类的原型，重写子类的原型实现继承，子类的原型的constructor 指向父类的实例 。<a  target="_blank"  href="../Ch06/PrototypeChainingExample01.htm">链接</a></p>
								<p>问题：父类包括引用类的原型,导致子类继承的引用型属性共享。<a  target="_blank"  href="../Ch06/PrototypeChainingExample02.htm"</p>
							</div>
							<div class="wrap">
								<h4>借用构造函数</h4>
								<p>在子类的构造函数的内部调用父类的构造函数，call(),apply()<a  target="_blank"  href="../Ch06/PrototypeChainingExample01.htm">链接</a></p>
								<p>问题：父类包括引用类的原型,导致子类继承的引用型属性共享。<a  target="_blank"  href="../Ch06/ConstructorStealingExample01.htm"></a></p>
							</div>
							<div class="wrap">
								<h4>组合继承</h4>
								<p>在子类的构造函数的内部调用父类的构造函数，call(),apply()，子类的原型继承父类的实例</p>
								<p>问题：两次调用父类的构造函数</p>
							</div>
							<div class="wrap">
								<h4>原型式继承</h4>
								<p>原型可以基于已有对象创建新对象，同事还不必要创建自定义类型，object对传进了的对象进行了一次浅复制<a  target="_blank"  href="../Ch06/PrototypalInheritanceExample01.htm"></a></p>
								<p></p>
							</div>
							<div class="wrap">
								<h4>寄生式继承</h4>
								<p>在创建的函数内部以某种方式增强变量，然后返回变量<a  target="_blank"  href="../Ch06/ParasiticCombinationInheritanceExample01.htm"></a></p>
								<p></p>
							</div>
							<div class="wrap">
								<h4>寄生组合继承</h4>
								<p>在寄生式继承的增强函数中重写子类的原型，不必要调用父类的构造函数，从而得到父类的父辈<a  target="_blank"  href="../Ch06/ParasiticCombinationInheritanceExample01.htm"></a></p>
								<p></p>
							</div>
						</div>
					</div>
					<div class="content" id="func1">
						<h3>函数</h3>
						<div class="wrap">
							<h4>函数声明，函数表达式</h4>
							<p>函数声明，函数声明提升，在调用之后声明亦可，函数表达式必须要在函数调用之前 <a target="_blank" href="../Ch07/FunctionDeclarationsErrorExample01.htm">函数声明</a></p>
							<p>函数声明 function a(){}</p>
							<p>函数表达式 a=function(){}</p>
						</div>
						<div class="wrap">
							<h4>闭包</h4>
							<p>有权访问另一个函数作用域中的变量的函数</p>
							<p>作用域链 </p>
							<p>闭包与变量<a href="prototype.html">闭包函数</a></p>
							<p>闭包中使用this,this是在运行时基于函数的执行环境绑定的，全局对象的this是window,匿名的this也是指向window</p>
							<p>没有块作用域,模仿块作用域 (function(){})()</p>
						</div>
					</div>
				</div>
				<!-- 右侧快速导航 -->
				<div class="col-xs-3 docs-sidebar">
					<ul class="nav" data-spy="affix" data-offset-top="300" data-offset-bottom="200">
						<li>
							<a href="#less1">Less模块化开发</a>
							<ul class="nav">
								<li><a href="#less2">gurnt配置</a></li>
								<li><a href="#less3">Less书写规范</a></li>
							</ul>
						</li>
						<li>
							<a href="#obj1">对象</a>
							<ul class="nav">
								<li><a href="#obj2">理解对象</a></li>
								<li><a href="#obj3">创建对象</a></li>
								<li><a href="#obj4">继承</a></li>
							</ul>
						</li>
						<li>
							<a href="#func1">函数</a>
							<ul class="nav">
								<li><a href="#func2">理解对象</a></li>
								<li><a href="#func3">创建对象</a></li>
								<li><a href="#func4">继承</a></li>
							</ul>
						</li>
					</ul>
				</div>
			</div>
		</div>

	</div>
	<script type="text/javascript" src="../dist/js/jquery.min.js"></script>
	<script type="text/javascript" src="../dist/js/bootstrap.min.js"></script>
	<!-- <script type="text/javascript" src="../dist/js/myless.js"></script> -->
</body>
</html>